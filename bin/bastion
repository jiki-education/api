#!/bin/bash
set -euo pipefail

# Bastion Host Access Script
# Starts an ECS bastion task and connects via ECS Exec
# Requires: aws-vault with MFA configured
# Usage: ./bin/bastion [--keep-alive] [--root] [--stop-all]
#   --keep-alive: Don't stop the bastion task on exit (for long-running sessions)
#   --root: Connect as root user (for system administration)
#   --stop-all: Stop all running bastion tasks and exit

CLUSTER="jiki-production"
TASK_FAMILY="jiki-bastion"
CONTAINER_NAME="bastion"
REGION="eu-west-1"
TERRAFORM_DIR="../terraform/terraform"
TASK_ID=""
KEEP_ALIVE=false
REUSED_TASK=false
ROOT_USER=false
STOP_ALL=false
# Temp file marker: when this file exists, the script is inside the interactive
# session and an unexpected exit (broken pipe) should NOT stop the bastion task.
# This uses the filesystem instead of bash variables because signals from the
# dying SSM session kill the bash process in a way that bypasses variable state.
SESSION_ACTIVE_MARKER=""

# Check if we're running with aws-vault, if not, re-exec with it
# This must happen BEFORE argument parsing so arguments are preserved
if [ -z "${AWS_VAULT:-}" ]; then
    exec aws-vault exec jiki -- "$0" "$@"
fi

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --keep-alive)
            KEEP_ALIVE=true
            shift
            ;;
        --root)
            ROOT_USER=true
            shift
            ;;
        --stop-all)
            STOP_ALL=true
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: ./bin/bastion [--keep-alive] [--root] [--stop-all]"
            exit 1
            ;;
    esac
done

# Handle --stop-all flag
if [ "$STOP_ALL" = true ]; then
    echo "üõë Stopping all running bastion tasks..."
    echo ""

    RUNNING_TASKS=$(aws ecs list-tasks \
        --cluster "$CLUSTER" \
        --family "$TASK_FAMILY" \
        --desired-status RUNNING \
        --region "$REGION" \
        --query 'taskArns[]' \
        --output text)

    if [ -z "$RUNNING_TASKS" ]; then
        echo "‚úì No running bastion tasks found"
        exit 0
    fi

    TASK_COUNT=$(echo "$RUNNING_TASKS" | wc -w | tr -d ' ')
    echo "Found $TASK_COUNT running bastion task(s)"
    echo ""

    for task_arn in $RUNNING_TASKS; do
        task_id=$(echo "$task_arn" | cut -d/ -f3)
        echo "Stopping task: $task_id"
        aws ecs stop-task \
            --cluster "$CLUSTER" \
            --task "$task_id" \
            --region "$REGION" > /dev/null
    done

    echo ""
    echo "‚úì All bastion tasks stopped"
    exit 0
fi

# Cleanup function - stops bastion task on exit/interrupt
cleanup() {
    # If we're inside the interactive session (marker file exists), the exit
    # was unexpected (broken pipe). Leave the task running so re-running the
    # script reconnects instantly.
    if [ -n "$SESSION_ACTIVE_MARKER" ] && [ -f "$SESSION_ACTIVE_MARKER" ]; then
        rm -f "$SESSION_ACTIVE_MARKER"
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "‚ö†Ô∏è  Connection lost unexpectedly. Bastion task left running."
        echo "   Re-run ./bin/bastion to reconnect to the same task."
        echo ""
        return
    fi

    if [ -n "$TASK_ID" ] && [ "$KEEP_ALIVE" = false ] && [ "$REUSED_TASK" = false ]; then
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "üßπ Cleaning up..."
        echo "Stopping bastion task..."
        aws ecs stop-task \
            --cluster "$CLUSTER" \
            --task "$TASK_ID" \
            --region "$REGION" > /dev/null 2>&1 || true
        echo "‚úì Bastion stopped"
        echo ""
        echo "üëã Goodbye!"
    elif [ "$KEEP_ALIVE" = true ]; then
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "‚è∏Ô∏è  Bastion task $TASK_ID left running (--keep-alive)"
        echo "   To stop it later, run: aws ecs stop-task --cluster $CLUSTER --task $TASK_ID --region $REGION"
        echo ""
        echo "üëã Goodbye!"
    elif [ "$REUSED_TASK" = true ]; then
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "‚è∏Ô∏è  Disconnected from existing bastion task (not stopped)"
        echo ""
        echo "üëã Goodbye!"
    fi

    rm -f "$SESSION_ACTIVE_MARKER"
}

# Trap to ensure cleanup on exit, interrupt, or termination.
# On INT/TERM: remove the marker first so cleanup knows it's intentional.
trap cleanup EXIT
trap 'rm -f "$SESSION_ACTIVE_MARKER"; exit 130' INT
trap 'rm -f "$SESSION_ACTIVE_MARKER"; exit 143' TERM

echo "üîê Bastion Access Script"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""
echo "‚úì Running with aws-vault profile: $AWS_VAULT"
if [ "$KEEP_ALIVE" = true ]; then
    echo "‚è∏Ô∏è  Keep-alive mode: bastion will not stop on exit"
fi
if [ "$ROOT_USER" = true ]; then
    echo "üë§ Root mode: connecting as root user"
fi
echo ""

# Check for existing bastion tasks
echo "üîç Checking for existing bastion tasks..."
EXISTING_TASK_ARN=$(aws ecs list-tasks \
    --cluster "$CLUSTER" \
    --family "$TASK_FAMILY" \
    --desired-status RUNNING \
    --region "$REGION" \
    --query 'taskArns[0]' \
    --output text)

if [ -n "$EXISTING_TASK_ARN" ] && [ "$EXISTING_TASK_ARN" != "None" ]; then
    TASK_ID=$(echo "$EXISTING_TASK_ARN" | cut -d/ -f3)
    TASK_ARN="$EXISTING_TASK_ARN"
    REUSED_TASK=true
    echo "‚úì Found existing bastion task: $TASK_ID"
    echo "  Connecting to existing task instead of starting a new one..."

    # Check if the existing task was started with --keep-alive
    TASK_KEEP_ALIVE=$(aws ecs describe-tasks \
        --cluster "$CLUSTER" \
        --tasks "$TASK_ARN" \
        --region "$REGION" \
        --query 'tasks[0].overrides.containerOverrides[0].environment[?name==`BASTION_KEEP_ALIVE`].value | [0]' \
        --output text)

    if [ "$TASK_KEEP_ALIVE" = "false" ]; then
        KEEP_ALIVE=false
        echo "  Task was started without --keep-alive, will stop on exit"
    elif [ "$TASK_KEEP_ALIVE" = "true" ]; then
        KEEP_ALIVE=true
        echo "  Task was started with --keep-alive, will not stop on exit"
    fi
    echo ""
else
    echo "‚úì No existing bastion task found, starting a new one..."
    echo ""

# Fetch bastion configuration from Terraform outputs
echo "üìã Fetching bastion configuration from Terraform..."

if [ ! -d "$TERRAFORM_DIR" ]; then
    echo "‚ùå ERROR: Terraform directory not found: $TERRAFORM_DIR"
    exit 1
fi

cd "$TERRAFORM_DIR"

# Get subnet IDs (comma-separated)
SUBNETS=$(terraform output -json bastion_subnet_ids | jq -r '. | join(",")')
if [ -z "$SUBNETS" ] || [ "$SUBNETS" = "null" ]; then
    echo "‚ùå ERROR: Could not fetch subnet IDs from Terraform"
    exit 1
fi

# Get security group ID
SECURITY_GROUP=$(terraform output -raw bastion_security_group_id)
if [ -z "$SECURITY_GROUP" ] || [ "$SECURITY_GROUP" = "null" ]; then
    echo "‚ùå ERROR: Could not fetch security group ID from Terraform"
    exit 1
fi

# Return to API directory
cd - > /dev/null

echo "‚úì Configuration loaded"
echo "  Subnets: $SUBNETS"
echo "  Security Group: $SECURITY_GROUP"
echo ""

# Start bastion task
echo "üöÄ Starting bastion task..."

# Build task overrides
# Note: user, logConfiguration, and linuxParameters are set in task definition
# We only override:
# - command: to add timeout wrapper for auto-stop
# - environment: to track keep-alive setting

# Base command (without timeout)
# Note: Using double quotes in echo to avoid quoting issues when wrapped in bash -c
BASE_COMMAND='chown -R rails:rails /rails && echo "Bastion ready for access" && tail -f /dev/null'

# Add timeout wrapper if not keeping alive
if [ "$KEEP_ALIVE" = false ]; then
    COMMAND="timeout 3600 bash -c '${BASE_COMMAND}' || echo \"Bastion auto-stopped after 1 hour\""
    KEEP_ALIVE_VALUE="false"
    echo "‚è≤Ô∏è  Auto-stop enabled: bastion will terminate after 1 hour of inactivity"
else
    COMMAND="$BASE_COMMAND"
    KEEP_ALIVE_VALUE="true"
fi

# Build final overrides JSON
OVERRIDES=$(jq -n \
  --arg cmd "$COMMAND" \
  --arg keep_alive "$KEEP_ALIVE_VALUE" \
  '{
    containerOverrides: [{
      name: "bastion",
      command: ["/bin/bash", "-c", $cmd],
      environment: [
        {name: "BASTION_KEEP_ALIVE", value: $keep_alive}
      ]
    }]
  }'
)

RUN_TASK_OUTPUT=$(aws ecs run-task \
  --cluster "$CLUSTER" \
  --task-definition "$TASK_FAMILY" \
  --launch-type FARGATE \
  --enable-execute-command \
  --overrides "$OVERRIDES" \
  --network-configuration "awsvpcConfiguration={
    subnets=[$SUBNETS],
    securityGroups=[$SECURITY_GROUP],
    assignPublicIp=ENABLED
  }" \
  --region "$REGION" \
  --query 'tasks[0].taskArn' \
  --output text 2>&1) || {
    if echo "$RUN_TASK_OUTPUT" | grep -q "AccessDeniedException"; then
        MY_IP=$(curl -s --max-time 5 ifconfig.me || echo "unknown")
        echo ""
        echo "‚ùå ERROR: Access denied - your IP ($MY_IP) is not in the bastion whitelist."
        echo ""
        echo "To fix this, add your IP to bastion_whitelisted_ips in:"
        echo "  terraform/terraform/aws/variables.tf"
        echo ""
        echo "Then run:"
        echo "  cd terraform/terraform"
        echo "  aws-vault exec jiki -- terraform apply"
    else
        echo ""
        echo "‚ùå ERROR: Failed to start bastion task"
        echo "$RUN_TASK_OUTPUT"
    fi
    exit 1
}
TASK_ARN="$RUN_TASK_OUTPUT"

if [ -z "$TASK_ARN" ] || [ "$TASK_ARN" = "None" ]; then
    echo "‚ùå ERROR: Failed to start bastion task"
    exit 1
fi

TASK_ID=$(echo "$TASK_ARN" | cut -d/ -f3)
echo "‚úì Bastion started: $TASK_ID"
echo ""

# Wait for task to be running
echo "‚è≥ Waiting for task to be ready..."
MAX_WAIT=60
WAITED=0

while [ $WAITED -lt $MAX_WAIT ]; do
    TASK_STATUS=$(aws ecs describe-tasks \
        --cluster "$CLUSTER" \
        --tasks "$TASK_ARN" \
        --region "$REGION" \
        --query 'tasks[0].lastStatus' \
        --output text)

    if [ "$TASK_STATUS" = "RUNNING" ]; then
        break
    fi

    if [ "$TASK_STATUS" = "STOPPED" ]; then
        echo "‚ùå ERROR: Task stopped unexpectedly"
        exit 1
    fi

    sleep 2
    WAITED=$((WAITED + 2))
    echo "  Status: $TASK_STATUS (${WAITED}s elapsed)"
done

if [ "$TASK_STATUS" != "RUNNING" ]; then
    echo "‚ùå ERROR: Task did not start within ${MAX_WAIT}s"
    echo "Stopping task..."
    aws ecs stop-task \
        --cluster "$CLUSTER" \
        --task "$TASK_ID" \
        --region "$REGION" > /dev/null
    exit 1
fi

echo "‚úì Task is running"
echo ""

# Wait for ECS Exec agent to be ready
echo "‚è≥ Waiting for ECS Exec agent to be ready..."
MAX_AGENT_WAIT=30
AGENT_WAITED=0

while [ $AGENT_WAITED -lt $MAX_AGENT_WAIT ]; do
    AGENT_STATUS=$(aws ecs describe-tasks \
        --cluster "$CLUSTER" \
        --tasks "$TASK_ARN" \
        --region "$REGION" \
        --query 'tasks[0].containers[0].managedAgents[?name==`ExecuteCommandAgent`].lastStatus' \
        --output text)

    if [ "$AGENT_STATUS" = "RUNNING" ]; then
        echo "‚úì ECS Exec agent is ready"
        break
    fi

    sleep 2
    AGENT_WAITED=$((AGENT_WAITED + 1))

    if [ $((AGENT_WAITED % 5)) -eq 0 ]; then
        echo "  Agent status: $AGENT_STATUS (${AGENT_WAITED}x2s elapsed)"
    fi
done

if [ "$AGENT_STATUS" != "RUNNING" ]; then
    echo "‚ö†Ô∏è  WARNING: ECS Exec agent not ready after ${MAX_AGENT_WAIT}x2s, attempting connection anyway..."
fi
echo ""
fi

# Choose command based on root mode
if [ "$ROOT_USER" = true ]; then
    EXEC_COMMAND="/bin/bash"
else
    EXEC_COMMAND="/bin/bash -c 'cd /rails && export HOME=/rails && exec setpriv --reuid=1000 --regid=1000 --clear-groups bash'"
fi

# Connect to bastion with auto-reconnect on broken pipe
# Create marker file: its presence tells cleanup "we're in a session, don't stop the task"
SESSION_ACTIVE_MARKER=$(mktemp)
USER_EXITED=false
MAX_RECONNECTS=30
RECONNECT_COUNT=0

while [ "$USER_EXITED" = false ]; do
    if [ $RECONNECT_COUNT -eq 0 ]; then
        echo "üîå Connecting to bastion..."
    else
        echo "üîå Reconnecting to bastion (attempt $RECONNECT_COUNT/$MAX_RECONNECTS)..."
    fi
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo ""
    if [ "$ROOT_USER" = false ]; then
        echo "Available commands:"
        echo "  ./bin/rails console    - Rails console"
        echo "  ./bin/rails dbconsole  - Database console"
        echo "  ./bin/rails runner ... - Run Ruby code"
    else
        echo "Running as root - use for system administration."
        echo "Switch to rails user: su rails"
    fi
    echo ""
    echo "Type 'exit' to disconnect and stop the bastion."
    echo ""

    # Run in a child bash process to isolate our script from signals
    # (SIGPIPE/SIGHUP) that the dying SSM session delivers to the process group.
    set +e
    bash -c 'aws ecs execute-command \
      --cluster "$1" \
      --task "$2" \
      --container "$3" \
      --interactive \
      --command "$4" \
      --region "$5"' _ "$CLUSTER" "$TASK_ID" "$CONTAINER_NAME" "$EXEC_COMMAND" "$REGION"
    EXIT_CODE=$?
    set -e

    # Exit code 0 means the user typed 'exit' cleanly
    if [ $EXIT_CODE -eq 0 ]; then
        USER_EXITED=true
        break
    fi

    RECONNECT_COUNT=$((RECONNECT_COUNT + 1))
    if [ $RECONNECT_COUNT -ge $MAX_RECONNECTS ]; then
        echo ""
        echo "‚ùå Too many disconnections ($MAX_RECONNECTS). Giving up."
        break
    fi

    # Check if the task is still running before reconnecting
    TASK_STATUS=$(aws ecs describe-tasks \
        --cluster "$CLUSTER" \
        --tasks "$TASK_ID" \
        --region "$REGION" \
        --query 'tasks[0].lastStatus' \
        --output text 2>/dev/null || echo "UNKNOWN")

    if [ "$TASK_STATUS" != "RUNNING" ]; then
        echo ""
        echo "‚ùå Bastion task is no longer running (status: $TASK_STATUS)"
        USER_EXITED=true
        break
    fi

    echo ""
    echo "‚ö†Ô∏è  Connection lost (broken pipe). Reconnecting in 2s..."
    echo "   Press Ctrl+C to disconnect instead."
    sleep 2
done

# Remove marker so cleanup knows this was a normal exit
rm -f "$SESSION_ACTIVE_MARKER"

# Cleanup handled by trap on EXIT
