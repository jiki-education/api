#!/usr/bin/env ruby

ENV['RAILS_ENV'] ||= 'development'

require 'bundler/setup'
require 'jiki-config'
require_relative '../../config/environment'

puts "=== Testing Video Merge Locally ==="
puts ""

# Build TypeScript if using local execution
if ENV['INVOKE_LAMBDA_LOCALLY']
  print "Building TypeScript... "
  Dir.chdir(File.join(__dir__, '..', '..', 'services', 'video_production', 'video-merger')) do
    result = system('npm run build > /dev/null 2>&1')
    unless result
      puts "✗"
      puts "Error: Failed to build TypeScript"
      exit 1
    end
  end
  puts "✓"
end

bucket = Jiki.config.s3_bucket_video_production

# Step 1: Check prerequisites
print "Checking LocalStack S3... "
begin
  Jiki.s3_client.head_bucket(bucket: bucket)
  puts "✓"
rescue StandardError => e
  puts "✗"
  puts "Error: LocalStack not accessible"
  puts "Run: bin/dev"
  exit 1
end

print "Checking Lambda function... "
begin
  Jiki.lambda_client.get_function(function_name: 'jiki-video-merger-development')
  puts "✓"
rescue StandardError => e
  puts "✗"
  puts "Error: Lambda function not deployed"
  puts "Run: bin/setup-video-production"
  exit 1
end

print "Checking test videos exist... "
begin
  Jiki.s3_client.head_object(bucket: bucket, key: 'test-assets/video1.mp4')
  Jiki.s3_client.head_object(bucket: bucket, key: 'test-assets/video2.mp4')
  puts "✓"
rescue StandardError => e
  puts "✗"
  puts "Error: Test videos not found"
  puts "Run: bin/seed-test-videos"
  exit 1
end

puts ""
puts "All prerequisites met!"
puts ""

# Step 2: Create pipeline
print "Creating test pipeline... "
pipeline = VideoProduction::Pipeline.create!(
  title: "Test Video Merge",
  version: "1.0",
  config: {}
)
puts "✓ (#{pipeline.uuid})"

# Step 3: Create asset nodes (with output already set since they're "completed")
print "Creating video asset nodes... "
video1 = VideoProduction::Node.create!(
  pipeline: pipeline,
  title: "Blue Video (3s)",
  type: "asset",
  asset: { type: "video", source: "s3://#{bucket}/test-assets/video1.mp4" },
  output: { type: "video", s3Key: "test-assets/video1.mp4" },
  status: "completed"
)

video2 = VideoProduction::Node.create!(
  pipeline: pipeline,
  title: "Red Video (3s)",
  type: "asset",
  asset: { type: "video", source: "s3://#{bucket}/test-assets/video2.mp4" },
  output: { type: "video", s3Key: "test-assets/video2.mp4" },
  status: "completed"
)
puts "✓"

# Step 4: Create merge node
print "Creating merge node... "
merge_node = VideoProduction::Node.create!(
  pipeline: pipeline,
  title: "Merged Video",
  type: "merge-videos",
  config: { "provider" => "ffmpeg" },
  inputs: { "segments" => [video1.uuid, video2.uuid] },
  status: "pending"
)
puts "✓ (#{merge_node.uuid})"

puts ""
puts "Pipeline created successfully!"
puts ""

# Step 5: Execute merge
puts "Executing video merge..."
puts "Input 1: s3://#{bucket}/test-assets/video1.mp4 (blue, 3s)"
puts "Input 2: s3://#{bucket}/test-assets/video2.mp4 (red, 3s)"
puts "Expected output: 6 second video (blue then red)"
puts ""

print "Invoking executor... "
begin
  VideoProduction::Node::Executors::MergeVideos.new(merge_node).call
  puts "✓ (async invocation)"
rescue StandardError => e
  puts "✗"
  puts "Error: #{e.message}"
  puts e.backtrace.first(5).join("\n")
  exit 1
end

# Step 6: Poll for completion (async execution)
print "Waiting for Lambda callback"
max_wait = 30 # seconds
wait_interval = 0.5 # seconds
elapsed = 0

loop do
  merge_node.reload
  break if merge_node.status == 'completed' || merge_node.status == 'failed'

  if elapsed >= max_wait
    puts " ✗"
    puts ""
    puts "Timeout: Node still in status '#{merge_node.status}' after #{max_wait}s"
    puts "Metadata: #{merge_node.metadata.inspect}"
    exit 1
  end

  print "."
  sleep wait_interval
  elapsed += wait_interval
end

puts " ✓ (#{elapsed.round(1)}s)"
puts ""

# Step 7: Check results
puts "=== Results ==="
puts ""
puts "Status: #{merge_node.status}"

if merge_node.status == 'completed'
  puts "Output:"
  puts "  S3 Key: #{merge_node.output['s3Key']}"
  puts "  Duration: #{merge_node.output['duration']}s"
  puts "  Size: #{merge_node.output['size'] / 1024}KB"
  puts ""
  puts "✓ Video merge completed successfully!"
  puts ""
  puts "Output location: s3://#{bucket}/#{merge_node.output['s3Key']}"
  puts ""
  puts "To download and verify:"
  puts "  bin/rails runner \"File.write('merged.mp4', Jiki.s3_client.get_object(bucket: '#{bucket}', key: '#{merge_node.output['s3Key']}').body.read)\""
  puts "  open merged.mp4  # Should show blue video (3s) then red video (3s)"
elsif merge_node.status == 'failed'
  puts "Error: #{merge_node.metadata['error']}"
  puts ""
  puts "✗ Video merge failed"
  exit 1
else
  puts "Status: #{merge_node.status}"
  puts "Metadata: #{merge_node.metadata.inspect}"
  puts ""
  puts "⚠ Unexpected status"
  exit 1
end
