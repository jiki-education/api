# I18n (Internationalization)

Jiki uses a database-backed translation system for educational content (lessons, levels) and email templates, with LLM-powered translation via Google's Gemini API.

## Configuration

### Locale Constants

**File**: `config/initializers/i18n.rb`

Two constants control locale availability:
- `I18n::SUPPORTED_LOCALES` - Production-ready locales available to users
- `I18n::WIP_LOCALES` - Work-in-progress locales (translations exist but not user-facing)

English is the source language. All other locales are translations stored in separate tables.

### User Locale Preference

**File**: `app/models/user.rb`

Users have a `locale` attribute validated against supported locales. This is used by:
- Serializers to return locale-specific content
- Mailers to send emails in the user's preferred language

## Translation Models

### Design Pattern

English content is stored on the main model (Level, Lesson). Translations for other locales are stored in separate `*::Translation` models. This keeps the main model clean while allowing unlimited translations.

### Translatable Concern

**File**: `app/models/concerns/translatable.rb`

Models include `Translatable` to gain translation support:

```ruby
# Get content for any locale (English from main model, others from translations with fallback)
def content_for_locale(locale)
  model = locale.to_s == 'en' ? self : (translations.find_by(locale:) || self)
  self.class.translatable_fields.index_with { |field| model.public_send(field) }
end

# Get translation record for a specific locale
def translation_for(locale)
  return nil if locale.to_s == 'en'
  translations.find_by(locale:)
end
```

### Level::Translation

**File**: `app/models/level/translation.rb`

Fields: `title`, `description`, `milestone_summary`, `milestone_content`, `locale`

Validations:
- Locale must NOT be 'en' (English stays on Level model)
- Locale must be in `SUPPORTED_LOCALES` or `WIP_LOCALES`
- Unique constraint on `[level_id, locale]`

### Lesson::Translation

**File**: `app/models/lesson/translation.rb`

Fields: `title`, `description`, `locale`

Same validation pattern as Level::Translation.

### EmailTemplate

**File**: `app/models/email_template.rb`

Unlike Level/Lesson, EmailTemplate stores all locales directly (including English):
Fields: `type`, `slug`, `locale`, `subject`, `body_mjml`, `body_text`

Unique constraint on `[type, slug, locale]`.

## Avoiding N+1 Queries

When serializing multiple items with translations, **do not call `content_for_locale` on each item**. This causes N+1 queries.

### Batch-Fetch Pattern

**File**: `app/serializers/serialize_levels.rb`

Pre-fetch all translations in a single query:

```ruby
memoize
def lesson_contents
  lessons = levels_with_includes.flat_map(&:lessons)

  # Build English content hash (used directly for :en, or as fallback)
  english_content = lessons.to_h { |l| [l.id, { title: l.title, description: l.description }] }

  return english_content if I18n.locale.to_s == "en"

  # Get translations in ONE query, merge with English fallback
  translated = Lesson::Translation.where(locale: I18n.locale, lesson: lessons).
    pluck(:lesson_id, :title, :description).
    to_h { |id, title, desc| [id, { title: title, description: desc }] }

  english_content.merge(translated)
end
```

Key techniques:
1. **Batch fetch** all translations with a single `pluck` query
2. **Memoize** results to avoid repeated queries
3. **English fallback** - build English hash first, overlay translations (missing translations automatically fall back)

Use `content_for_locale` only for single-item serialization (e.g., `SerializeLesson` for one lesson).

## LLM-Powered Translation

### Translation Commands

All translation commands use `Gemini::Translate` (see `.context/llm.md`):

| Command | Purpose |
|---------|---------|
| `Level::Translation::TranslateToLocale` | Translate level to single locale |
| `Level::Translation::TranslateToAllLocales` | Queue jobs for all non-English locales |
| `Lesson::Translation::TranslateToLocale` | Translate lesson to single locale |
| `Lesson::Translation::TranslateToAllLocales` | Queue jobs for all non-English locales |
| `EmailTemplate::TranslateToLocale` | Translate email template to single locale |
| `EmailTemplate::TranslateToAllLocales` | Queue jobs for all non-English locales |

### Translation Queue

Jobs run in the `:translations` Sidekiq queue with automatic retry on rate limits.

## Locale-Aware Serializers

Controllers set `I18n.locale` based on user preference. Serializers then use this:

```ruby
# Single item - use content_for_locale
content_data = lesson.content_for_locale(I18n.locale)

# Multiple items - use batch-fetch pattern (see above)
```

## Admin Translation Endpoints

Trigger translation jobs via admin API:

- `POST /admin/levels/:level_id/translations/translate` - Queue level translations
- `POST /admin/lessons/:lesson_id/translations/translate` - Queue lesson translations
- `POST /admin/email_templates/:id/translate` - Queue email translations

All return 202 Accepted with `queued_locales` array.

## YAML Locale Files

**Directory**: `config/locales/`

Static UI strings (not database content) use standard Rails I18n YAML files:
- Base translations in `config/locales/*.yml`
- Mailer-specific in `config/locales/mailers/*.yml`

## Adding a New Locale

1. Add locale code to `I18n::WIP_LOCALES` in `config/initializers/i18n.rb`
2. Create YAML locale files in `config/locales/`
3. Translate existing content via admin endpoints
4. When ready for production, move from `WIP_LOCALES` to `SUPPORTED_LOCALES`
5. Update User model validation to include new locale

## Related Documentation

- `.context/llm.md` - Gemini API integration details
- `.context/serializers.md` - Serialization patterns
- `.context/mailers.md` - Email i18n patterns
